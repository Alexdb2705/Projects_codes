import numpy as np

def cartesian_to_spherical(x, y, z):
    """Converts Cartesian coordinates to spherical coordinates.

    Args:
        x (float): X coordinate.
        y (float): Y coordinate.
        z (float): Z coordinate.

    Returns:
        tuple: (theta, phi) where theta is in (0, pi) and phi is in (0, 2pi).
    """
    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(z / r)  # Polar angle (0 to pi)
    phi = np.arctan2(y, x)    # Azimuthal angle (0 to 2pi)
    if phi < 0:
        phi += 2 * np.pi  # Ensure phi is in (0, 2pi)
    return theta, phi

def generate_spherical_coordinates_file(n, angle, width, m, cone_width, filename, pov=None):
    """Generates a text file with n samples of random spherical coordinates and additional variations.

    Each sample consists of a random unit direction in spherical coordinates. Additional directions 
    are generated by modifying either the theta or phi value within a specified width.

    Args:
        n (int): Number of samples to generate.
        angle (str): Angle to modify ("theta" or "phi").
        width (float): Range of variation in degrees for the selected angle.
        m (int): Number of directions to generate per sample.
        pov (str): Which part of the object will be being looked.
        cone_width (float): Width of the cone of view when pov is present.
        filename (str, optional): Output file name.
    """

    def pov_angles(pov, cw):
        povs = {"front": (90, 0), "left_side": (90, 90), "right_side": (90, 270), "back": (90, 180), "top": (1, 1), "bottom": (180, 1)}
        general = cw * (np.random.rand() * 2 - 1)
        return (general + povs[pov][0]) * np.pi/180, (general + povs[pov][1]) * np.pi/180

    width = np.radians(width)  # Convert width from degrees to radians
    
    with open(filename, "w") as f:
        for _ in range(n):
            if pov:  # Positive x axis
                theta, phi = pov_angles(pov, cone_width)
            else:
                # Generate a single random unit vector
                v = np.random.randn(3)
                v /= np.linalg.norm(v)
                theta, phi = cartesian_to_spherical(*v)
            
            # Generate additional directions centered on theta|phi
            if angle == "theta":
                values = np.linspace(theta - width, theta + width, m)
                for _, t in enumerate(values):
                    f.write(f"{t}|{phi}\n")
            elif angle == "phi":
                values = np.linspace(phi - width, phi + width, m) 
                for _, p in enumerate(values):
                    f.write(f"{theta}|{p}\n")

def generate_frequency_file(central_freq, freq_width, m, filename):
    """Generates a text file with frequency values centered around a given central frequency.

    Args:
        central_freq (float): The central frequency value.
        freq_width (float): The range of variation around the central frequency. Half of the total range.
        m (int): Number of frequencies to generate.
        filename (str, optional): Output file name.
    """
    with open(filename, "w") as f:
        freq_values = np.linspace(central_freq - freq_width, central_freq + freq_width, m)
        for _, freq in enumerate(freq_values):
            f.write(f"{freq}\n")

# Example usage
# generate_spherical_coordinates_file(16, "phi", 20, 16, "spherical_coordinates.txt")
# generate_frequency_file(1e10, 2e9, 16, "frequencies.txt") # Un rango habitual es de 9 a 11 GHz, 128 muestras 
